---
phase: 04-integration-and-polish
plan: 05
type: execute
wave: 2
depends_on: [04-02]
files_modified:
  - components/proposals/CommentItem.tsx
  - components/proposals/CommentThread.tsx
  - landing-page-new/src/components/CommentItem.tsx
  - landing-page-new/src/components/CommentThread.tsx
autonomous: true
gap_closure: true

must_haves:
  truths:
    - "Edit button only appears on own comments without subsequent replies"
    - "Edit button hidden after another user replies to the comment"
    - "Edit button visible on most recent comment by user (no replies yet)"
    - "Edit button logic works correctly in both admin and client portals"
  artifacts:
    - path: "components/proposals/CommentThread.tsx"
      provides: "Computes hasSubsequentReplies for each comment, passes to CommentItem"
      pattern: "hasSubsequentReplies"
    - path: "components/proposals/CommentItem.tsx"
      provides: "Edit button conditional includes hasSubsequentReplies check"
      pattern: "isOwner.*hasSubsequentReplies"
    - path: "landing-page-new/src/components/CommentThread.tsx"
      provides: "Client portal subsequent replies computation"
      pattern: "hasSubsequentReplies"
    - path: "landing-page-new/src/components/CommentItem.tsx"
      provides: "Client portal edit button logic"
      pattern: "isOwner.*hasSubsequentReplies"
  key_links:
    - from: "CommentThread"
      to: "CommentItem"
      via: "hasSubsequentReplies prop"
      pattern: "hasSubsequentReplies=\\{.*\\}"
    - from: "CommentItem edit button"
      to: "visibility logic"
      via: "isOwner && !hasSubsequentReplies"
      pattern: "isOwner.*!hasSubsequentReplies"
---

<objective>
Implement edit button visibility logic that only shows edit option on user's own comments when no subsequent replies exist from other users.

Purpose: Prevent users from editing comments after conversation has progressed, maintaining conversation integrity.
Output: Edit button appears only on most recent comment by each user, hidden after replies.
</objective>

<execution_context>
@./.claude/get-shit-done/workflows/execute-plan.md
@./.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/ROADMAP.md
@.planning/STATE.md
@.planning/phases/04-integration-and-polish/04-UAT.md
@.planning/phases/04-integration-and-polish/04-01-SUMMARY.md

## Root Cause (from UAT diagnosis)

**Gaps 7, 8, 9: Edit button appears on all own comments (major)**
- Root cause: Edit button visibility only checks ownership (isOwner) without checking if subsequent comments exist from other users
- Admin portal: `components/proposals/CommentItem.tsx` line 154, `components/proposals/CommentThread.tsx` lines 224-231
- Client portal: `landing-page-new/src/components/CommentItem.tsx` line 154, `landing-page-new/src/components/CommentThread.tsx`
- Current logic: `{isOwner && <button>Edit</button>}`
- Needed logic: `{isOwner && !hasSubsequentReplies && <button>Edit</button>}`

**Missing pieces:**
1. CommentThread needs to compute hasSubsequentReplies for each comment
2. CommentThread needs to pass hasSubsequentReplies prop to CommentItem
3. CommentItem needs hasSubsequentReplies prop in interface
4. CommentItem edit button conditional needs to check hasSubsequentReplies

## Definition of "Subsequent Reply"

A comment has subsequent replies if:
- There exists at least one comment posted AFTER it (later createdAt timestamp)
- Posted by a DIFFERENT user (different author_id)
- In the same proposal thread (same proposalId)

User can still edit if:
- It's their own comment (isOwner = true)
- No one else has replied after it (hasSubsequentReplies = false)
- Allows users to edit most recent comment, even if they posted multiple in a row

## Debug Sessions

See detailed analysis:
- `.planning/debug/edit-button-all-comments.md`
</context>

<tasks>

<task type="auto">
  <name>Task 1: Compute hasSubsequentReplies in CommentThread</name>
  <files>
components/proposals/CommentThread.tsx
landing-page-new/src/components/CommentThread.tsx
  </files>
  <action>
In both CommentThread components, add logic to compute `hasSubsequentReplies` for each comment before rendering.

**Add helper function (~line 50-70):**
```typescript
// Check if a comment has replies from other users posted after it
const computeHasSubsequentReplies = (
  comment: Comment,
  allComments: Comment[],
  currentUserId: string
): boolean => {
  // Find comments posted after this one
  const subsequentComments = allComments.filter(
    c => new Date(c.created_at) > new Date(comment.created_at)
  );

  // Check if any subsequent comment is from a different user
  return subsequentComments.some(
    c => c.author_id !== currentUserId
  );
};
```

**Update comment rendering (~line 220-240):**
```typescript
{comments.map((comment, index) => {
  const isOwner = comment.author_id === userId; // or clientId in client portal
  const hasSubsequentReplies = computeHasSubsequentReplies(
    comment,
    comments,
    userId // or clientId in client portal
  );

  return (
    <CommentItem
      key={comment.id}
      {...comment}
      isOwner={isOwner}
      hasSubsequentReplies={hasSubsequentReplies}
      onEdit={handleEdit}
    />
  );
})}
```

**Important considerations:**
- In admin portal: Use `userId` for ownership check
- In client portal: Use `clientId` for ownership check
- Comments array should be sorted by created_at ascending (oldest first)
- Ensure author_id field exists in Comment type

Apply to both:
1. `components/proposals/CommentThread.tsx` (admin portal)
2. `landing-page-new/src/components/CommentThread.tsx` (client portal)
  </action>
  <verify>
Code inspection:
1. `grep -n "computeHasSubsequentReplies" components/proposals/CommentThread.tsx` shows function definition
2. `grep -n "hasSubsequentReplies" components/proposals/CommentThread.tsx` shows prop being passed to CommentItem
3. Same for client portal files
4. Function logic correctly identifies subsequent comments from different users
  </verify>
  <done>
CommentThread computes hasSubsequentReplies for each comment and passes to CommentItem in both portals.
  </done>
</task>

<task type="auto">
  <name>Task 2: Add hasSubsequentReplies prop to CommentItem and update edit button logic</name>
  <files>
components/proposals/CommentItem.tsx
landing-page-new/src/components/CommentItem.tsx
  </files>
  <action>
In both CommentItem components, add `hasSubsequentReplies` prop to interface and update edit button conditional to use it.

**Update interface (~line 10-20):**
```typescript
interface CommentItemProps {
  id: string;
  content: string;
  author_name: string;
  author_id: string;
  created_at: string;
  updated_at?: string;
  isOwner: boolean;
  hasSubsequentReplies: boolean; // NEW
  onEdit?: (id: string, newContent: string) => Promise<void>;
  // ... other props
}
```

**Update edit button conditional (~line 150-160):**
```typescript
{/* Current: Only checks isOwner */}
{isOwner && (
  <button onClick={handleEditClick}>Edit</button>
)}

{/* Updated: Check both isOwner AND no subsequent replies */}
{isOwner && !hasSubsequentReplies && (
  <button onClick={handleEditClick}>Edit</button>
)}
```

**Why this works:**
- `isOwner`: User can only edit their own comments
- `!hasSubsequentReplies`: User can only edit if no one else replied after
- Both conditions must be true for edit button to appear

Apply to both:
1. `components/proposals/CommentItem.tsx` (admin portal)
2. `landing-page-new/src/components/CommentItem.tsx` (client portal)
  </action>
  <verify>
Code inspection:
1. Both CommentItem files have hasSubsequentReplies in props interface
2. Both edit button conditionals include `!hasSubsequentReplies` check
3. TypeScript compiles without errors (parent passing prop, child receiving it)
  </verify>
  <done>
Edit button conditional updated. Prop interface includes hasSubsequentReplies. TypeScript compilation successful.
  </done>
</task>

<task type="auto">
  <name>Task 3: Manual test edit button behavior across scenarios</name>
  <files>N/A</files>
  <action>
This is a verification-only task to test the edit button logic in multiple scenarios.

**Test Scenario 1: Edit button on most recent comment (should show)**
1. User A posts Comment 1
2. User A should see Edit button on Comment 1 (no replies yet)

**Test Scenario 2: Edit button hidden after other user replies (should hide)**
1. User A posts Comment 1
2. User B posts Comment 2 (reply)
3. User A should NOT see Edit button on Comment 1 (has reply from User B)

**Test Scenario 3: Edit button on multiple consecutive comments (should show on last)**
1. User A posts Comment 1
2. User A posts Comment 2
3. User A posts Comment 3
4. User A should see Edit button ONLY on Comment 3 (most recent)
5. Comment 1 and 2 should have no edit button (Comment 3 came after them)

**Test Scenario 4: Edit button after self-reply (should show)**
1. User A posts Comment 1
2. User A posts Comment 2
3. User A should see Edit button on Comment 2 (reply to self is allowed)

**Test Scenario 5: Both portals behave identically**
1. Test all above scenarios in admin portal
2. Test all above scenarios in client portal
3. Behavior should match exactly

Run tests manually using browser:
- Admin portal: `http://localhost:3001/admin/proposal/{id}`
- Client portal: `http://localhost:3000/proposal/{id}`
- Use different browser profiles or incognito windows to simulate multiple users
  </action>
  <verify>
Checklist (all must pass):
- [ ] Edit button visible on most recent own comment with no replies
- [ ] Edit button hidden after another user replies
- [ ] Edit button only on last comment when user posts multiple in a row
- [ ] Edit button visible when replying to own comment
- [ ] Admin portal behavior matches test scenarios
- [ ] Client portal behavior matches test scenarios
- [ ] No console errors during testing
  </verify>
  <done>
All test scenarios pass. Edit button logic correct in both portals. Edit button only appears on own comments without subsequent replies from other users.
  </done>
</task>

</tasks>

<verification>

**Visual verification in browser:**

Test Matrix:

| Scenario | Comment Owner | Has Subsequent Reply? | Edit Button? |
|----------|---------------|----------------------|--------------|
| Just posted | User A | No | ✅ Visible |
| User B replied | User A | Yes (from User B) | ❌ Hidden |
| Multiple by User A | User A | No (all by same user) | ✅ On last only |
| Self-reply | User A | No (reply from self) | ✅ Visible |

**Database state verification:**
```sql
SELECT
  id,
  author_id,
  author_name,
  content,
  created_at
FROM proposal_comments
WHERE proposal_id = '<test-proposal-id>'
ORDER BY created_at ASC;
```

Should clearly show comment order and ownership for manual inspection.

**Test both portals:**
- Admin portal: Superadmin editing their comments
- Client portal: Client editing their comments
</verification>

<success_criteria>

1. Edit button appears on user's own comments without subsequent replies
2. Edit button hidden after another user posts reply
3. Edit button only on most recent comment when user posts multiple consecutively
4. Self-replies do not hide edit button (same user replies to self)
5. Both admin and client portals implement identical logic
6. TypeScript compilation successful with new prop
7. No console errors when rendering comments
8. Manual test scenarios all pass

</success_criteria>

<output>
After completion, create `.planning/phases/04-integration-and-polish/04-05-SUMMARY.md`
</output>

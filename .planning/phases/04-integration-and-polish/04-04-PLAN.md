---
phase: 04-integration-and-polish
plan: 04
type: execute
wave: 2
depends_on: [04-02]
files_modified:
  - components/proposals/CommentThread.tsx
  - landing-page-new/src/components/CommentThread.tsx
autonomous: true
gap_closure: true

must_haves:
  truths:
    - "New comments appear automatically on client screen without manual refresh"
    - "Page scrolls to show new comment when posted by another user"
    - "Scroll position preserved when user reading middle of thread"
    - "Auto-scroll only happens when user near bottom or after own comment"
  artifacts:
    - path: "components/proposals/CommentThread.tsx"
      provides: "Fixed polling with stable closure, smart auto-scroll logic"
      pattern: "useRef.*lastPolledAt|scrollBehavior"
    - path: "landing-page-new/src/components/CommentThread.tsx"
      provides: "Client portal polling and auto-scroll"
      pattern: "useRef.*lastPolledAt|scrollBehavior"
  key_links:
    - from: "pollForNewComments"
      to: "lastPolledAt timestamp"
      via: "useRef to avoid stale closure"
      pattern: "lastPolledAtRef\\.current"
    - from: "pollForNewComments"
      to: "scrollToBottom"
      via: "detect scroll position, conditionally scroll"
      pattern: "scrollHeight.*scrollTop.*clientHeight"
---

<objective>
Fix polling stale closure bug so new comments appear automatically, and implement smart auto-scroll that shows new comments when user near bottom while preserving scroll when reading middle.

Purpose: Resolve polling failure (new comments only visible after refresh) and missing auto-scroll behavior.
Output: Real-time updates work, scroll intelligently adapts to user position.
</objective>

<execution_context>
@./.claude/get-shit-done/workflows/execute-plan.md
@./.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/ROADMAP.md
@.planning/STATE.md
@.planning/phases/04-integration-and-polish/04-UAT.md
@.planning/phases/04-integration-and-polish/04-01-SUMMARY.md

## Root Causes (from UAT diagnosis)

**Gap 5: Polling not showing new comments (major)**
- Root cause: pollForNewComments has stale closure bug - captures lastPolledAt from useState but useEffect dependency array missing it, causing function to always use initial timestamp
- Location: `components/proposals/CommentThread.tsx` lines 27-127
- Fix: Use useRef for lastPolledAt instead of useState, OR add lastPolledAt to dependency array, OR use useCallback with proper dependencies

**Gap 6: Page doesn't scroll to new comment (major)**
- Root cause: CommentThread lacks auto-scroll logic. Scroll-preservation mechanism actively prevents scrolling by restoring previous scroll position
- Location: Both CommentThread components
- Fix: Implement smart auto-scroll - detect if user near bottom, auto-scroll if near bottom, preserve if reading middle, always scroll after own comment

## Debug Sessions

See detailed analysis:
- `.planning/debug/client-polling-not-showing-new-comments.md`
- `.planning/debug/scroll-to-new-comment.md`

## Recommended Approach

**For stale closure:** Use useRef pattern (cleanest, no dependency array complications)

**For auto-scroll:** Calculate scroll position threshold (e.g., within 100px of bottom = "near bottom"), conditionally scroll based on position
</context>

<tasks>

<task type="auto">
  <name>Task 1: Fix polling stale closure with useRef</name>
  <files>
components/proposals/CommentThread.tsx
landing-page-new/src/components/CommentThread.tsx
  </files>
  <action>
In both CommentThread components, convert `lastPolledAt` from useState to useRef to avoid stale closure in pollForNewComments.

**Current code (both portals, ~line 27-50):**
```typescript
const [lastPolledAt, setLastPolledAt] = useState<Date>(new Date());

const pollForNewComments = useCallback(async () => {
  // Stale closure: lastPolledAt captured from initial render
  const newComments = await getComments(proposalId, lastPolledAt);
  // ...
  setLastPolledAt(new Date());
}, [proposalId]); // Missing lastPolledAt in dependencies
```

**Fixed code:**
```typescript
// Use ref instead of state to avoid stale closure
const lastPolledAtRef = useRef<Date>(new Date());

const pollForNewComments = useCallback(async () => {
  // Always reads current value from ref
  const newComments = await getComments(proposalId, lastPolledAtRef.current);

  if (newComments && newComments.length > 0) {
    setComments(prev => [...prev, ...newComments]);
    // Update ref with current timestamp
    lastPolledAtRef.current = new Date();
  }
}, [proposalId]); // No need for lastPolledAtRef in dependencies
```

**Why this works:** useRef provides stable reference across renders. Updating `.current` doesn't trigger re-renders, and reading `.current` always gets latest value - no stale closure.

Apply to both:
1. `components/proposals/CommentThread.tsx` (admin portal)
2. `landing-page-new/src/components/CommentThread.tsx` (client portal)
  </action>
  <verify>
Manual test:
1. Open proposal in client portal (browser A)
2. Open same proposal in admin portal (browser B)
3. Post comment in browser B
4. Wait 10 seconds (polling interval)
5. Verify comment appears in browser A WITHOUT refreshing page
6. Check console - no "Failed to fetch comments" errors
7. Check Network tab - polling requests use updated timestamp in `since` parameter
  </verify>
  <done>
New comments appear automatically via polling. No manual refresh needed. Polling uses current timestamps, not stale initial value.
  </done>
</task>

<task type="auto">
  <name>Task 2: Implement smart auto-scroll for new comments</name>
  <files>
components/proposals/CommentThread.tsx
landing-page-new/src/components/CommentThread.tsx
  </files>
  <action>
In both CommentThread components, add smart auto-scroll logic that:
- Scrolls to bottom when user near bottom (within 100px)
- Preserves scroll position when user reading middle
- Always scrolls after user posts own comment

**Add scroll detection helper (~line 40-50):**
```typescript
// Check if user is near bottom of comment thread
const isNearBottom = () => {
  if (!scrollContainerRef.current) return false;
  const { scrollHeight, scrollTop, clientHeight } = scrollContainerRef.current;
  const distanceFromBottom = scrollHeight - scrollTop - clientHeight;
  return distanceFromBottom < 100; // Within 100px of bottom
};

// Scroll to bottom smoothly
const scrollToBottom = () => {
  if (!scrollContainerRef.current) return;
  scrollContainerRef.current.scrollTo({
    top: scrollContainerRef.current.scrollHeight,
    behavior: 'smooth'
  });
};
```

**Update pollForNewComments to conditionally scroll (~line 80-100):**
```typescript
const pollForNewComments = useCallback(async () => {
  const newComments = await getComments(proposalId, lastPolledAtRef.current);

  if (newComments && newComments.length > 0) {
    const wasNearBottom = isNearBottom();

    setComments(prev => [...prev, ...newComments]);
    lastPolledAtRef.current = new Date();

    // Auto-scroll if user was near bottom
    if (wasNearBottom) {
      // Use setTimeout to ensure DOM updated before scrolling
      setTimeout(() => scrollToBottom(), 50);
    }
    // Otherwise preserve scroll position (existing scrollPosRef logic)
  }
}, [proposalId]);
```

**Update handleSubmit to always scroll after own comment (~line 140-160):**
```typescript
const handleSubmit = async (content: string, attachmentIds?: string[]) => {
  try {
    await createComment({
      proposalId,
      content,
      userId,
      userName,
      attachmentIds,
    });

    // Always scroll to show own comment
    setTimeout(() => scrollToBottom(), 100);

    // Reset polling timestamp to fetch own comment
    lastPolledAtRef.current = new Date();
  } catch (error) {
    // ...
  }
};
```

**Ensure scrollContainerRef attached to scrollable element:**
Verify that the comment list container has the ref:
```typescript
<div ref={scrollContainerRef} onScroll={handleScroll} className="...">
  {comments.map(comment => <CommentItem key={comment.id} {...comment} />)}
</div>
```

Apply to both:
1. `components/proposals/CommentThread.tsx` (admin portal)
2. `landing-page-new/src/components/CommentThread.tsx` (client portal)
  </action>
  <verify>
Manual test (two browsers):

**Test 1: Auto-scroll when near bottom**
1. Open proposal with 10+ comments
2. Scroll to bottom
3. Post new comment from other browser
4. Wait 10 seconds
5. Verify: Page scrolls smoothly to show new comment

**Test 2: Preserve scroll when reading middle**
1. Open proposal with 10+ comments
2. Scroll to middle of thread
3. Post new comment from other browser
4. Wait 10 seconds
5. Verify: Scroll position unchanged (no jump to bottom)

**Test 3: Always scroll after own comment**
1. Post a comment
2. Verify: Page scrolls to show newly posted comment immediately
3. No need to scroll manually to see own comment
  </verify>
  <done>
Smart auto-scroll implemented. Comments appear at bottom when user near bottom. Scroll preserved when reading middle. Own comments always visible after posting.
  </done>
</task>

</tasks>

<verification>

**Polling behavior:**
```bash
# Two browser windows, same proposal
# Browser A: Client portal
# Browser B: Admin portal

# Post comment in Browser B
# Within 10 seconds, comment appears in Browser A
# No manual refresh needed
```

**Auto-scroll behavior:**
1. User near bottom (within 100px): New comment → auto-scroll
2. User in middle: New comment → preserve position
3. User posts comment: Auto-scroll to show own comment
4. Smooth scrolling (behavior: 'smooth')

**Test both portals:**
- Admin portal (Vite SPA)
- Client portal (Next.js)
</verification>

<success_criteria>

1. Polling fetches new comments automatically every 10 seconds
2. New comments appear without manual page refresh
3. Polling uses current timestamps (no stale closure)
4. Page scrolls to new comment when user near bottom
5. Scroll position preserved when user reading middle
6. Own comments always visible after posting (auto-scroll)
7. Smooth scroll animation (not instant jump)
8. Both admin and client portals have working polling and auto-scroll

</success_criteria>

<output>
After completion, create `.planning/phases/04-integration-and-polish/04-04-SUMMARY.md`
</output>
